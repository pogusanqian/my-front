<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<style>
    #mycanvas {
        border: 1px solid black;
        margin: auto;
    }
</style>

<body>
    <canvas id="mycanvas" width="702" height="1032px"></canvas>
</body>
<script>
    const canvas = document.getElementById('mycanvas');
    const ctx = canvas.getContext('2d');
    ctx.fillStyle = 'red';
    ctx.font = " 24px PingFangSC";

    const img1 = new Image();
    const img2 = new Image();
    img1.src = '../source/imgs/社群背景图.png';
    img2.src = '../source/imgs/美女1.jpg';

    // 此时的img是读取不到宽高属性的, 引用图片的实际长宽不会赋值到img标签上
    console.log(img1.width, img1.height);

    /**
     *  这里必须放在onload事件中, 如果直接drawImage会渲染不到画布上, 
     *  1. 如果绘制两个图片到画布, 不能一个一个的加载, 因为我们不知道谁先加载完, 如果img2先加载完, 就会被img1覆盖掉
     *              img1.onload = () => ctx.drawImage(img1, 0, 0);
     *              img2.onload = () => ctx.drawImage(img2, 400, 860);
     * 
     *  2. 也不能只使用一个事件, 因为img2加载的后img1可能还没有加载
     *              img2.onload = () => {
     *                      ctx.drawImage(img1, 0, 0);
     *                       ctx.drawImage(img2, 400, 860);
     *                  }
     */
    function myonload() { // 这种抽取的方法时挺怪异的, 这里的参数img1, img2都不是传递过来的, 而是取自父上下文; 而这就是闭包
        if (img1.complete && img2.complete) {
            // 进行渲染
            ctx.drawImage(img1, 0, 0, 702, 1032);
            ctx.drawImage(img2, 111, 351, 480, 480);
            ctx.fillText('美女-1001', 280, 843, 142, 40);

            // 进行下载
            const a = document.createElement("a");
            a.href = canvas.toDataURL();
            a.download = "qrcode"; // 图片名 
            a.click();
        }
    };
    img2.onload = myonload;
    img1.onload = myonload;
</script>

</html>