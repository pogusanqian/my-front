<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <script type="text/javascript" src="../../T01-HTML+CSS/source/vue.js"></script>
    <style>
        *{
            margin-top: 30px;
        }
    </style>
</head>

<body>
    <div id="demo">
        姓名: <input type="text" v-model="firstName"><br>
        年龄: <input type="text" v-model="lastName"><br><br>
        全称: <span>{{fullName}}</span><br>
        
    </div>
</body>
<script>
    Vue.config.productionTip = false;
    const vm = new Vue({
        el: '#demo',
        data: {
            firstName: '张',
            lastName: '三'
        },
        /*
            computer表示计算属性, 计算属性必须使用get和set进行赋值, 相比较于methods中的方法, copmuted中的属性是有缓存的
            get方法只有再初始化以及所依赖的数据发生变化时, 才会进行调用
            set方法只有当fullName属性直接发生变化时, 通过修改firstName,lastName引起的fullName变化时不会引起set方法的调用的
            注意我们的fullName属性只依赖于firstName和lastName这两个属性, 如果我们再控制器中直接修改vm.fullName时, fullName的值时不会改变的,我们必须再setter中修改firstName, lastName
        */
        computed: {
            fullName: {
                get() {
                    return `${this.firstName}-${this.lastName}`;
                },
                set(value) {
                    console.log(value);
                    const arr = value.split('-');
                    this.firstName = arr[0];
                    this.lastName = arr[1];
                }
            },
            // 如果只有get方法时, 可以简写成这样
            simpleFullName(){
                return `${this.firstName}-${this.lastName}`;
            }
        }
    })
</script>

</html>